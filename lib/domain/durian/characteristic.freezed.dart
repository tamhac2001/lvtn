// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'characteristic.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Characteristic _$CharacteristicFromJson(Map<String, dynamic> json) {
  return _Characteristic.fromJson(json);
}

/// @nodoc
mixin _$Characteristic {
  Root? get root => throw _privateConstructorUsedError;
  Trunk? get trunk => throw _privateConstructorUsedError;
  Leaf? get leaf => throw _privateConstructorUsedError;
  Flower? get flower => throw _privateConstructorUsedError;
  Fruit? get fruit => throw _privateConstructorUsedError;
  Seed? get seed => throw _privateConstructorUsedError;
  Flavour? get flavour => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CharacteristicCopyWith<Characteristic> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacteristicCopyWith<$Res> {
  factory $CharacteristicCopyWith(
          Characteristic value, $Res Function(Characteristic) then) =
      _$CharacteristicCopyWithImpl<$Res>;
  $Res call(
      {Root? root,
      Trunk? trunk,
      Leaf? leaf,
      Flower? flower,
      Fruit? fruit,
      Seed? seed,
      Flavour? flavour});

  $RootCopyWith<$Res>? get root;
  $TrunkCopyWith<$Res>? get trunk;
  $LeafCopyWith<$Res>? get leaf;
  $FlowerCopyWith<$Res>? get flower;
  $FruitCopyWith<$Res>? get fruit;
  $SeedCopyWith<$Res>? get seed;
  $FlavourCopyWith<$Res>? get flavour;
}

/// @nodoc
class _$CharacteristicCopyWithImpl<$Res>
    implements $CharacteristicCopyWith<$Res> {
  _$CharacteristicCopyWithImpl(this._value, this._then);

  final Characteristic _value;
  // ignore: unused_field
  final $Res Function(Characteristic) _then;

  @override
  $Res call({
    Object? root = freezed,
    Object? trunk = freezed,
    Object? leaf = freezed,
    Object? flower = freezed,
    Object? fruit = freezed,
    Object? seed = freezed,
    Object? flavour = freezed,
  }) {
    return _then(_value.copyWith(
      root: root == freezed
          ? _value.root
          : root // ignore: cast_nullable_to_non_nullable
              as Root?,
      trunk: trunk == freezed
          ? _value.trunk
          : trunk // ignore: cast_nullable_to_non_nullable
              as Trunk?,
      leaf: leaf == freezed
          ? _value.leaf
          : leaf // ignore: cast_nullable_to_non_nullable
              as Leaf?,
      flower: flower == freezed
          ? _value.flower
          : flower // ignore: cast_nullable_to_non_nullable
              as Flower?,
      fruit: fruit == freezed
          ? _value.fruit
          : fruit // ignore: cast_nullable_to_non_nullable
              as Fruit?,
      seed: seed == freezed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as Seed?,
      flavour: flavour == freezed
          ? _value.flavour
          : flavour // ignore: cast_nullable_to_non_nullable
              as Flavour?,
    ));
  }

  @override
  $RootCopyWith<$Res>? get root {
    if (_value.root == null) {
      return null;
    }

    return $RootCopyWith<$Res>(_value.root!, (value) {
      return _then(_value.copyWith(root: value));
    });
  }

  @override
  $TrunkCopyWith<$Res>? get trunk {
    if (_value.trunk == null) {
      return null;
    }

    return $TrunkCopyWith<$Res>(_value.trunk!, (value) {
      return _then(_value.copyWith(trunk: value));
    });
  }

  @override
  $LeafCopyWith<$Res>? get leaf {
    if (_value.leaf == null) {
      return null;
    }

    return $LeafCopyWith<$Res>(_value.leaf!, (value) {
      return _then(_value.copyWith(leaf: value));
    });
  }

  @override
  $FlowerCopyWith<$Res>? get flower {
    if (_value.flower == null) {
      return null;
    }

    return $FlowerCopyWith<$Res>(_value.flower!, (value) {
      return _then(_value.copyWith(flower: value));
    });
  }

  @override
  $FruitCopyWith<$Res>? get fruit {
    if (_value.fruit == null) {
      return null;
    }

    return $FruitCopyWith<$Res>(_value.fruit!, (value) {
      return _then(_value.copyWith(fruit: value));
    });
  }

  @override
  $SeedCopyWith<$Res>? get seed {
    if (_value.seed == null) {
      return null;
    }

    return $SeedCopyWith<$Res>(_value.seed!, (value) {
      return _then(_value.copyWith(seed: value));
    });
  }

  @override
  $FlavourCopyWith<$Res>? get flavour {
    if (_value.flavour == null) {
      return null;
    }

    return $FlavourCopyWith<$Res>(_value.flavour!, (value) {
      return _then(_value.copyWith(flavour: value));
    });
  }
}

/// @nodoc
abstract class _$$_CharacteristicCopyWith<$Res>
    implements $CharacteristicCopyWith<$Res> {
  factory _$$_CharacteristicCopyWith(
          _$_Characteristic value, $Res Function(_$_Characteristic) then) =
      __$$_CharacteristicCopyWithImpl<$Res>;
  @override
  $Res call(
      {Root? root,
      Trunk? trunk,
      Leaf? leaf,
      Flower? flower,
      Fruit? fruit,
      Seed? seed,
      Flavour? flavour});

  @override
  $RootCopyWith<$Res>? get root;
  @override
  $TrunkCopyWith<$Res>? get trunk;
  @override
  $LeafCopyWith<$Res>? get leaf;
  @override
  $FlowerCopyWith<$Res>? get flower;
  @override
  $FruitCopyWith<$Res>? get fruit;
  @override
  $SeedCopyWith<$Res>? get seed;
  @override
  $FlavourCopyWith<$Res>? get flavour;
}

/// @nodoc
class __$$_CharacteristicCopyWithImpl<$Res>
    extends _$CharacteristicCopyWithImpl<$Res>
    implements _$$_CharacteristicCopyWith<$Res> {
  __$$_CharacteristicCopyWithImpl(
      _$_Characteristic _value, $Res Function(_$_Characteristic) _then)
      : super(_value, (v) => _then(v as _$_Characteristic));

  @override
  _$_Characteristic get _value => super._value as _$_Characteristic;

  @override
  $Res call({
    Object? root = freezed,
    Object? trunk = freezed,
    Object? leaf = freezed,
    Object? flower = freezed,
    Object? fruit = freezed,
    Object? seed = freezed,
    Object? flavour = freezed,
  }) {
    return _then(_$_Characteristic(
      root: root == freezed
          ? _value.root
          : root // ignore: cast_nullable_to_non_nullable
              as Root?,
      trunk: trunk == freezed
          ? _value.trunk
          : trunk // ignore: cast_nullable_to_non_nullable
              as Trunk?,
      leaf: leaf == freezed
          ? _value.leaf
          : leaf // ignore: cast_nullable_to_non_nullable
              as Leaf?,
      flower: flower == freezed
          ? _value.flower
          : flower // ignore: cast_nullable_to_non_nullable
              as Flower?,
      fruit: fruit == freezed
          ? _value.fruit
          : fruit // ignore: cast_nullable_to_non_nullable
              as Fruit?,
      seed: seed == freezed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as Seed?,
      flavour: flavour == freezed
          ? _value.flavour
          : flavour // ignore: cast_nullable_to_non_nullable
              as Flavour?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Characteristic
    with DiagnosticableTreeMixin
    implements _Characteristic {
  const _$_Characteristic(
      {this.root,
      this.trunk,
      this.leaf,
      this.flower,
      this.fruit,
      this.seed,
      this.flavour});

  factory _$_Characteristic.fromJson(Map<String, dynamic> json) =>
      _$$_CharacteristicFromJson(json);

  @override
  final Root? root;
  @override
  final Trunk? trunk;
  @override
  final Leaf? leaf;
  @override
  final Flower? flower;
  @override
  final Fruit? fruit;
  @override
  final Seed? seed;
  @override
  final Flavour? flavour;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Characteristic(root: $root, trunk: $trunk, leaf: $leaf, flower: $flower, fruit: $fruit, seed: $seed, flavour: $flavour)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Characteristic'))
      ..add(DiagnosticsProperty('root', root))
      ..add(DiagnosticsProperty('trunk', trunk))
      ..add(DiagnosticsProperty('leaf', leaf))
      ..add(DiagnosticsProperty('flower', flower))
      ..add(DiagnosticsProperty('fruit', fruit))
      ..add(DiagnosticsProperty('seed', seed))
      ..add(DiagnosticsProperty('flavour', flavour));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Characteristic &&
            const DeepCollectionEquality().equals(other.root, root) &&
            const DeepCollectionEquality().equals(other.trunk, trunk) &&
            const DeepCollectionEquality().equals(other.leaf, leaf) &&
            const DeepCollectionEquality().equals(other.flower, flower) &&
            const DeepCollectionEquality().equals(other.fruit, fruit) &&
            const DeepCollectionEquality().equals(other.seed, seed) &&
            const DeepCollectionEquality().equals(other.flavour, flavour));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(root),
      const DeepCollectionEquality().hash(trunk),
      const DeepCollectionEquality().hash(leaf),
      const DeepCollectionEquality().hash(flower),
      const DeepCollectionEquality().hash(fruit),
      const DeepCollectionEquality().hash(seed),
      const DeepCollectionEquality().hash(flavour));

  @JsonKey(ignore: true)
  @override
  _$$_CharacteristicCopyWith<_$_Characteristic> get copyWith =>
      __$$_CharacteristicCopyWithImpl<_$_Characteristic>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CharacteristicToJson(
      this,
    );
  }
}

abstract class _Characteristic implements Characteristic {
  const factory _Characteristic(
      {final Root? root,
      final Trunk? trunk,
      final Leaf? leaf,
      final Flower? flower,
      final Fruit? fruit,
      final Seed? seed,
      final Flavour? flavour}) = _$_Characteristic;

  factory _Characteristic.fromJson(Map<String, dynamic> json) =
      _$_Characteristic.fromJson;

  @override
  Root? get root;
  @override
  Trunk? get trunk;
  @override
  Leaf? get leaf;
  @override
  Flower? get flower;
  @override
  Fruit? get fruit;
  @override
  Seed? get seed;
  @override
  Flavour? get flavour;
  @override
  @JsonKey(ignore: true)
  _$$_CharacteristicCopyWith<_$_Characteristic> get copyWith =>
      throw _privateConstructorUsedError;
}
